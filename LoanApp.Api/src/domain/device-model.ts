export type DeviceModelProps = {
  id: string;
  brand: string;
  modelName: string;
  category: string;
  description?: string;
  stock: number;
  createdAt: Date;
};

export type DeviceDTO = {
  id: string;
  brand: string;
  modelName: string;
  category: string;
  description?: string;
  stock: number;
  createdAt: string;
};

export type ValidationError = {
  field: string;
  message: string;
};

export type Result<T> =
  | { success: true; value: T }
  | { success: false; errors: ValidationError[] };

/**
 * Device is an immutable, plain object exposing its values and a toJSON for serialization.
 */
export type Device = Readonly<{
  id: string;
  brand: string;
  modelName: string;
  category: string;
  description?: string;
  stock: number;
  createdAt: Date;
  toJSON: () => DeviceDTO;
}>;

/*----------------------helpers----------------------*/

const isNonEmptyString = (v: unknown): v is string =>
  typeof v === "string" && v.trim().length > 0;

const isFiniteNumber = (v: unknown): v is number =>
  typeof v === "number" && Number.isFinite(v);

// Module-scoped incremental id generator so ids increase across factory calls
let _lastGeneratedId = Date.now();
const generateId = (): string => {
  _lastGeneratedId += 1;
  return String(_lastGeneratedId);
};

/* -------------------- factory -------------------- */

/**
 * createDevice
 * - accepts a single parameter object
 * - validates required fields (id, name, stock)
 * - returns Result<Device>
 */
export const createDevice = (input: {
  id?: unknown;
  brand?: unknown;
  modelName?: unknown;
  category?: unknown;
  description?: unknown;
  stock?: unknown;
  createdAt?: unknown;
}): Result<Device> => {
  const errors: ValidationError[] = [];

  // id will be autogenerated when not provided. If provided, it must be a non-empty string.
  let id: string;

  if (input.id === undefined) {
    id = generateId();
  } else if (!isNonEmptyString(input.id)) {
    errors.push({
      field: "id",
      message: "id must be a non-empty string when provided",
    });
  } else {
    id = input.id;
  }

  if (!isNonEmptyString(input.brand)) {
    errors.push({
      field: "brand",
      message: "brand is required and must be a non-empty string",
    });
  }

  if (!isNonEmptyString(input.modelName)) {
    errors.push({
      field: "modelName",
      message: "model name is required and must be a non-empty string",
    });
  }

  if (!isNonEmptyString(input.category)) {
    errors.push({
      field: "category",
      message: "category is required and must be a non-empty string",
    });
  }
  if (
    input.description !== undefined &&
    typeof input.description !== "string"
  ) {
    errors.push({
      field: "description",
      message: "description must be a string when provided",
    });
  }

  if (
    typeof input.stock !== "number" ||
    Number.isNaN(input.stock!) ||
    input.stock < 0 ||
    !Number.isInteger(input.stock)
  ) {
    errors.push({
      field: "totalStock",
      message: "totalStock is required and must be a non-negative integer",
    });
  }

  let createdAt: Date;
  if (input.createdAt === undefined) {
    createdAt = new Date();
  } else if (input.createdAt instanceof Date) {
    if (isNaN(input.createdAt.getTime())) {
      errors.push({
        field: "createdAt",
        message: "createdAt must be a valid Date",
      });
    } else {
      createdAt = input.createdAt;
    }
  } else if (typeof input.createdAt === "string") {
    const parsed = new Date(input.createdAt);
    if (isNaN(parsed.getTime())) {
      errors.push({
        field: "createdAt",
        message: "createdAt string must be a valid date",
      });
    } else {
      createdAt = parsed;
    }
  } else {
    errors.push({
      field: "createdAt",
      message: "createdAt must be a Date or ISO string",
    });
  }

  if (errors.length > 0) {
    return { success: false, errors };
  }

  // At this point types are safe to assert
  const device: Device = Object.freeze({
    id: id as string,
    brand: input.brand as string,
    modelName: input.modelName as string,
    category: input.category as string,
    stock: input.stock as number,
    description: input.description as string | undefined,
    createdAt: createdAt!,
    toJSON: () =>
      ({
        id: id as string,
        brand: input.brand as string,
        modelName: input.modelName as string,
        category: input.category as string,
        stock: input.stock as number,
        description: input.description as string | undefined,
        createdAt: (createdAt as Date).toISOString(),
      } as DeviceDTO),
  });

  return { success: true, value: device };
};

/**
 * hydrateDevice
 * - constructs a Device from values returned by persistence (DB/DTO)
 * - performs minimal coercion (createdAt string -> Date) and validation
 * - does NOT generate ids; it expects the persistence layer to provide them
 */
export const hydrateDevice = (dto: {
  id?: unknown;
  brand?: unknown;
  modelName?: unknown;
  category?: unknown;
  description?: unknown;
  stock?: unknown;
  createdAt?: unknown;
}): Result<Device> => {
  const errors: ValidationError[] = [];

  if (!isNonEmptyString(dto.id)) {
    errors.push({
      field: "id",
      message: "id is required and must be a non-empty string from persistence",
    });
  }

  if (!isNonEmptyString(dto.brand)) {
    errors.push({
      field: "brand",
      message: "brand is required and must be a non-empty string",
    });
  }

  if (!isNonEmptyString(dto.modelName)) {
    errors.push({
      field: "modelName",
      message: "model name is required and must be a non-empty string",
    });
  }

  if (!isNonEmptyString(dto.category)) {
    errors.push({
      field: "category",
      message: "category is required and must be a non-empty string",
    });
  }

  if (dto.description !== undefined && typeof dto.description !== "string") {
    errors.push({
      field: "description",
      message: "description must be a string when provided",
    });
  }

  if (
    typeof dto.stock !== "number" ||
    Number.isNaN(dto.stock!) ||
    dto.stock < 0 ||
    !Number.isInteger(dto.stock)
  ) {
    errors.push({
      field: "stock",
      message: "stock is required and must be a positive integer",
    });
  }

  let createdAt: Date;
  if (dto.createdAt === undefined) {
    errors.push({
      field: "createdAt",
      message: "createdAt is required from persistence",
    });
  } else if (dto.createdAt instanceof Date) {
    if (isNaN(dto.createdAt.getTime())) {
      errors.push({
        field: "createdAt",
        message: "createdAt must be a valid Date",
      });
    } else {
      createdAt = dto.createdAt;
    }
  } else if (typeof dto.createdAt === "string") {
    const parsed = new Date(dto.createdAt);
    if (isNaN(parsed.getTime())) {
      errors.push({
        field: "createdAt",
        message: "createdAt string must be a valid date",
      });
    } else {
      createdAt = parsed;
    }
  } else {
    errors.push({
      field: "createdAt",
      message: "createdAt must be a Date or ISO string",
    });
  }

  if (errors.length > 0) return { success: false, errors };

  const device: Device = Object.freeze({
    id: dto.id as string,
    brand: dto.brand as string,
    modelName: dto.modelName as string,
    category: dto.category as string,
    description: dto.description as string | undefined,
    stock: dto.stock as number,
    createdAt: createdAt!,
    toJSON: () =>
      ({
        id: dto.id as string,
        brand: dto.brand as string,
        modelName: dto.modelName as string,
        category: dto.category as string,
        description: dto.description as string | undefined,
        stock: dto.stock as number,
        createdAt: (createdAt as Date).toISOString(),
      } as DeviceDTO),
  });

  return { success: true, value: device };
};
